var store = [{
        "title": "포스팅 테스트",
        "excerpt":"포스팅 테스트중 🎈  ","categories": ["Php"],
        "tags": ["php"],
        "url": "/php/first-post/",
        "teaser": null
      },{
        "title": "IntelliJ IDEA 윈도우 단축키",
        "excerpt":"[IntelliJ IDEA 윈도우버전 단축키]   ctrl + alt + v : 변수 추출(Extract Variable) Optional 불러옴 ctrl + alt + m : 리팩토링 단축키(Extract Method)   shift + f6 : 폴더 및 파일명 변경(Rename) class에서 ctrl + shift + t 하면 createTest 만들어짐  ","categories": ["Java"],
        "tags": ["java"],
        "url": "/java/intellij-post/",
        "teaser": null
      },{
        "title": "Couponsend",
        "excerpt":"매일 수강인증한 회원에 한해 특정 쿠폰이 발급되어야 한다는 내용의 요청을 받았다.  운영팀에서 인증한 회원의 ID를 게시판에 등록하면, 나는 해당 게시글의 idx값만 확인한 후 수동으로 호출해주면 되게끔 하였다.  추가기능(카카오 알림톡 - 현재 회사에서는 별도로 사용하는 api가 있음) + 쿠폰 발급 로그   @session_start();  MySQLConnectDB();  $send_cupon = \"Y\"; //쿠폰발급여부 $event_idx = 0; //event_idx 현재 없음 $send_sms = \"N\"; //sms 발송 여부 $event_date = date(\"Y-m-d\"); //이벤트확인날짜 오늘  $cuponname = \"수강인증 할인쿠폰\"; //쿠폰이름 $persent = 50; //할인율 $startdate = $event_date; //시작일 $timestamp = strtotime(\"+7 days\"); //쿠폰유효기간 $enddate = date(\"Y-m-d\", $timestamp); //쿠폰사용 종료일 $cupon_state = 0; //쿠폰사용여부 0-사용안함, 1-사용함 $cuponNO= 0;  $condition_value = \"조건 없음\";  $idx = $_GET['idx']; //$idx = 7;  $event_type = \"0124_event_promotion\"; $today = date(\"Ymd\");  $promotion_select_sql = \"SELECT context FROM 2022_event_promotion WHERE idx=\".$idx; $promotion_select_res = MySQLQuery($promotion_select_sql); $promotion_select_list = MySQLFetchArray($promotion_select_res);  $useridarray = $promotion_select_list['context']; $useridarray = explode(\",\",$useridarray);  for($i=0; $i&lt;count($useridarray); $i++) {     $userid = trim($useridarray[$i]);     //중복발급 확인     $dup_sql = \"SELECT count(*) as cnt from 2022_condition_coupon_log\";     $dup_sql .= \" WHERE send_cupon= 'Y' AND event_type='$event_type' and userid='$userid'\";     $dup_res = MySQLQuery($dup_sql);     $dup_list = MySQLFetchArray($dup_res);      if ($dup_list['cnt'] &gt; 0) //중복발급인 경우     {         $msg = \"중복 발급입니다. ID:\" . $userid . \"&lt;br&gt;\";;         $send_cupon = \"N\";         $send_sms = \"N\";         echo $msg;         $msg = iconv(\"EUC-KR\", \"UTF-8\", $msg);         insert_condition_log($userid, $event_idx, $event_type, $condition_value, $send_cupon, $cuponNO, $send_sms, $event_date, $msg);     } else {         $cuponNO = cuponNO();          //조건없음         $send_cupon = \"Y\";         $condition_value = \"조건없음\";          //쿠폰의 사용 여부 확인 ( 사용했으면 1, 사용하지 않았으면 0)         $cupon_insert_sql = \"insert into my_cupon (userid,cuponname,couponNO,persent,startdate,enddate,cupon_state) \";         $cupon_insert_sql .= \"values ('$userid','$cuponname','$cuponNO.',$persent, '$startdate', '$enddate', '$cupon_state')\";         $copon_insert_result = MySQLQuery($cupon_insert_sql);          $msg = \"쿠폰이 발급되었습니다. : \". $userid. \"&lt;br&gt;\";         echo $msg;         $msg = iconv(\"EUC-KR\", \"UTF-8\", $msg);           $member_select_sql = \"SELECT * FROM tbl_member WHERE user_id='$userid'\";         $member_select_res = MySQLQuery($member_select_sql);             while ($member_select_list = MySQLFetchArray($member_select_res)) {                 $sendanswer = $member_select_list['sendanswer'];                 $member_id = $member_select_list['user_id'];                 $member_name = $member_select_list['user_name'];                 $member_phone = $member_select_list['home_phone'];//휴대폰 번호                  if($sendanswer == \"Y\" || $sendanswer == \"예\") {                     $send_sms = \"Y\";                      //알림톡 전송                     $post_data = array(                         \"id\" =&gt; iconv('EUC-KR', 'UTF-8', $member_id),                         \"name\" =&gt; iconv('EUC-KR', 'UTF-8', $member_name),                         \"hp_num\" =&gt; iconv('EUC-KR', 'UTF-8', $member_phone),                     );                      $ch = curl_init();                     curl_setopt($ch, CURLOPT_URL, \"https://url\");//해당 링크를 통해 카카오톡 발송 api를 사용                     curl_setopt($ch, CURLOPT_POST, 1);                                          //SSL 필수 시작 - HTTPS일때 필수                     curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);                     curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0);                     //SSL 필수 끝                     curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);                     $output = curl_exec($ch);                      $curl_errno = curl_errno($ch);                     $curl_error = curl_error($ch);                      $info = curl_getinfo($ch);                      curl_close($ch);                  } else {                     $send_sms = \"N\";                 }             }             //로그 남기기             insert_condition_log($userid, $event_idx, $event_type, $condition_value, $send_cupon, $cuponNO, $send_sms, $event_date, $msg);      } }   밑에는 insert_condition_log 함수 내용(공통 파일에 넣어져있다)   /*   ┌──────────────────────────────────────────────────────┐   │▒ 함수명 : insert_condition_log()                    ▒│   │▒ 설  명 : 조건 발급 쿠폰 로그                        ▒│   │▒                                                    ▒│   │▒ 입력값 : $userid : userid, $event_idx :이벤트 idx   │▒ 입력값 : $event_type : 이벤트type, $condition_value :조건   │▒ 입력값 : $send_cupon : 쿠폰발급여부, $cuponNO :쿠폰번호   │▒ 입력값 : $send_sms : sms발신여부, $event_date : 이벤트시작일   │▒ 입력값 : $message : 사용자 메시지   │▒ 리턴값 : 없음                                      ▒│   └──────────────────────────────────────────────────────┘*/ function insert_condition_log($userid, $event_idx, $event_type, $condition_value, $send_cupon, $cuponNO, $send_sms, $event_date, $message) {   //id, event_idx(이벤트 idx)-지금은 없음,    //event_type(이벤트타입)-지금은 0124_event 고정,    //condition_value(조건:값) 내용-결제금액&gt;10만원:$결제금액   //send_cupon(발급여부)-Y,N couponNO,    //send_sms(sms 송신여부)-지금은N,    //event_date(이벤트날짜,오늘), reg_date(등록일시) condition_coupon_log에 내용 저장 \t//조건에 안맞아도 무조건 log에는 기입 \t$message = iconv(\"UTF-8\", \"EUC-KR\", $message); \t$cupon_log_insert_sql = \" INSERT INTO 테이블명(userid, event_idx, event_type, condition_value, send_cupon, couponNO, send_sms, event_date, message, reg_date)\"; \t$cupon_log_insert_sql .= \" VALUES ('$userid','$event_idx','$event_type', '$condition_value', '$send_cupon', '$cuponNO','$send_sms', '$event_date', '$message', NOW())\"; \t$cupon_log_result = MySQLQuery($cupon_log_insert_sql); }   이렇게 소스코드로 짜여진 coupon.php 파일을 도메인에 idx값과 함께 수동으로 입력하면  해당하는 사람들에게 해당 쿠폰(수강인증 할인쿠폰)이 자동으로 발급되고 카카오 안내톡도 발송된다.  EX) https://www.test.kr/coupon.php?idx=7  ","categories": [],
        "tags": [],
        "url": "/couponsend/",
        "teaser": null
      },{
        "title": "Ubuntu폴더 윈도우(windows)에서 열기",
        "excerpt":"windows를 사용하면서 wsl을 설치해 ubuntu를 사용하는 사람이라면 윈도우에서 ubuntu 폴더를 열어보고 싶은 경우가 있다. 그럴 때 간단하게 사용하는 명령어는   explorer.exe .                      이렇게 명령어를 입력하면                         윈도우에서 해당 폴더가 있는 창이 열린다.       ","categories": ["Ubuntu"],
        "tags": ["ubuntu"],
        "url": "/ubuntu/ubuntuopen/",
        "teaser": null
      },{
        "title": "There are no gemspecs at 오류 발생시 해결방안",
        "excerpt":"깃허브 블로그를 local에서 실행하려고 해당 명령어를 입력한 순간,   bundle exec jekyll serve        아래와 같은 에러가 발생했다.                               [!] There was an error parsing `Gemfile`: There are no gemspecs at /home/ashley/seolhee-choi.github.io. Bundler cannot continue.                                      사진에 있는 Gemfile을 눌러서 들어간뒤                                      #gemspec 하단에 아래 3줄을 추가했다.                                              다시 'bundle exec jekyll serve' 명령어 입력해보면 정상으로 작동되는 것이 확인됨                 ","categories": ["ETC"],
        "tags": ["etc"],
        "url": "/etc/bundlererror/",
        "teaser": null
      },{
        "title": "MySQL에서 LIKE IN 대신 사용가능한 REGEXP",
        "excerpt":"한 컬럼에 여러 값이 저장되있는 경우, LIKE를 이용해서 여러 조건을 검색하고 싶었다.  LIKE와 IN을 함께 쓸 수 있나 찾아봤지만 MySQL에서는 불가능했고😥  대체 방안으로 REGEXP를 찾아냈다.   SELECT        a.certificate AS '관심자격증'     FROM          '테이블명' AS a     WHERE         a.certificate REGEXP 'part2_no57_lecture|part2_no2_lecture'     ORDER BY         regdate DESC;                       (기존 데이터들이 json 식으로 저장 되있다..왜 이렇게 저장했을까..아주 엉망진창🤬)          위에 쿼리문처럼 입력하면 'part2_no57_lecture' 와 'part2_no2_lecture'가 해당되있는          결과값이 조회되는걸 확인할 수 있다.          LIKE로만 조건을 검색했더라면 굉장히 길고 효율성없는 쿼리문을 짤 수 밖에없었는데,          REGEXP가 날 살렸다!       ","categories": ["MySQL"],
        "tags": ["mysql"],
        "url": "/mysql/mysqluse_1/",
        "teaser": null
      },{
        "title": "List와 ArrayList의 차이",
        "excerpt":"List와 ArrayList의 차이   List는 인터페이스고 ArrayList는 클래스이다.      클래스는 일반클래스와, abstract로 정의된 추상 클래스로 나뉨   인터페이스는 모든 메서드가 추상 메서드인 경우를 의미 / 인터페이스를 상속받는 클래스는 인터페이스에서 정의된 추상 메서드를 모두 구현해야함 (따라서 다양한 클래스를 상속받는 특정 인터페이스는 결국 동일한 메서드를 제공함)   하나의 예를 보자.   List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();  // list1을 ArrayList객체로 만듦 list1 = new LinkedList&lt;Integer&gt;(); // 그리고 이렇게 LinkedList 객체로도 대체가 가능함   이유는 List가 인터페이스인데, 이런 인터페이스의 추상메소드를 구현하는게 ArrayList, LinkedList 둘 다 가능하기 때문이다.        예제  ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();      list1에 아이템 추가시에는 add를 사용 : list.add(1),list1.add(2);   list1의 특정 아이템을 읽을시 get(인덱스번호)을 사용 : list1.get (0);   ⇒ 1   list1의 특정 인덱스에 해당하는 아이템 변경시 set을 사용 : list1.set(0,5);   ⇒ 1이었던 값이 5로 바뀜   list1의 특정 인덱스에 해당하는 아이템 삭제시 remove를 사용 : list1.remove(0);   ⇒ 2(0번째의 인덱스값이 사라지고 1번째에 있던 값이 0의 자리로 옴)   list1의 배열 길이 확인은 : list1.size();   ⇒ 1        3차원 배열 출력 연습   public class Test {     public static void main(String[] args) {       Integer [][][] data_list = {         {             {1,2,3},             {4,5,6}         },         {             {7,8,9},             {10,11,12}         }       };       //3차원 배열에서 8, 10, 2를 순서대로 출력해보기       System.out.println(data_list[1][0][1]);       System.out.println(data_list[1][1][0]);       System.out.println(data_list[0][0][1]);     }  }           배열.length : 배열에 들어있는 아이템 개수   문자열.indexOf(String key) : String key가 해당 문자열에 있으면 해당 문자의 위치(index값)를 리턴하고, 없으면 -1을 리턴함   public class Test {     public static void main(String[] args) {          String str = \"HelloSpring\";         System.out.println(str.indexOf(\"S\"));         //\"S\"의 index 위치는 5번째이므로 값은 5가 된다.     } }  ","categories": ["Algorithm"],
        "tags": ["algorithm"],
        "url": "/algorithm/algorithm_list_arraylist/",
        "teaser": null
      },{
        "title": "큐(Queue)의 구조",
        "excerpt":"큐 구조      가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 구조   FIFO(First in First out) / LILO(Last in Last out)방식으로 이루어짐   큐에는 Enqueue(add(value), offer(value))와 Dequeue(poll(), remove()) 종류가 있음   Queue를 사용하기 위해서는 LinkedList 클래스를 사용해야하고,  어떤 데이터타입을 사용할건지 자료형 매개변수를 넣어서 지정해줘야함   import java.util.LinkedList; import java.util.Queue;  public class Test_queue {     public static void main(String[] args) {          Queue&lt;Integer&gt; q_int = new LinkedList&lt;Integer&gt;();         Queue&lt;String&gt; q_str = new LinkedList&lt;String&gt;();     } }     💡Enqueue와 Dequeue                  큐에 데이터를 추가하기 위해서는 add(value) , offer(value)를 사용        q_int.add(1),q_int.offer(2);                       큐에 들어있는 데이터를 출력할 때는 해당 인스턴스를 사용        System.out.println(q_int); ⇒ [1, 2]                        큐에 들어있는 첫 번째 값을 반환하고, 해당 첫 번째 값을 삭제할때는 poll이나 remove를 사용        q_int.poll(); , q_int_remove()     ⇒ 큐에 들어있는 첫 번째 값은 1이므로 1이 삭제되고 2만 남는다.           import java.util.LinkedList; import java.util.Queue;  public class Test_queue {     public static void main(String[] args) {          Queue&lt;Integer&gt; q_int = new LinkedList&lt;Integer&gt;();         Queue&lt;String&gt; q_str = new LinkedList&lt;String&gt;();          q_int.add(1);         q_int.offer(2);          q_str.add(\"m\");         q_str.offer(\"om\");         q_str.poll();          System.out.println(q_int); // 1,2가 출력됨         System.out.println(q_str); // \"m\"이 제거되어 \"om\"만 출력됨     }  }       📝Enqueue와 Dequeue를 사용해보자   import java.util.ArrayList;  public class Test_queue&lt;T&gt; {     private ArrayList&lt;T&gt; queue = new ArrayList&lt;T&gt;();      public void enqueue(T i) {         queue.add(i);     }      //데이터를 꺼내오는거라 별도의 인자가 없음     public T dequeue() {          if (queue.isEmpty()) {             return null;         }         return queue.remove(0);     }      //Test_queue 클래스가 데이터를 갖고있는지 여부를 확인하기 위한 메소드     public boolean isEmpty() {          return queue.isEmpty();     }      public static void main(String[] args) {         Test_queue&lt;Integer&gt; tq = new Test_queue&lt;Integer&gt;();         tq.enqueue(1);  //1을 넣고         tq.enqueue(2);  //2를 넣고         tq.enqueue(3);  //3을 넣었다         System.out.println(tq.dequeue()); //1을 빼고         System.out.println(tq.dequeue()); //2를 빼고         System.out.println(tq.dequeue()); //3을 뺌     } }    값은 순서대로 1 2 3 이 출력된다.  ","categories": ["Algorithm"],
        "tags": ["algorithm"],
        "url": "/algorithm/algorithm_queue/",
        "teaser": null
      },{
        "title": "Notion 로그아웃(원격 로그아웃)",
        "excerpt":"노션을 사용하다가 브라우저를 그대로 종료하면 로그아웃이 되지않는다.  노션을 사용하면서 불편한 점 중 하나가 아닐까 싶다😥      그러다 문득, 내가 로그인했던 모든 session들의 device에서 로그아웃 해주는 원격 로그아웃 기능이 있을 것 같아 문의해보았다.         이전엔 없었던 기능이라 다들 고객센터에 문의했던거같은데 기능이 추가된건지 위와 같은 방법을 답변받았다.        1) 노션의 왼쪽 사이드바 상단에 있는 Settings&amp;Members를 클릭한다.            2) 왼쪽 사이드바의 맨 상단에 My account를 클릭           3) 별표 표시해놓은 부분에서 Logout 버튼을 클릭하면 현재 기기를 제외한 나머지 기기에서 로그아웃이 된다.          ","categories": ["ETC"],
        "tags": ["etc"],
        "url": "/etc/notion_logout/",
        "teaser": null
      },{
        "title": "스택(Stack)의 구조",
        "excerpt":"스택(Stack)   스택은 LIFO(Last In, First Out) 또는 FILO(First In, Last Out) 데이터 관리 방식을 따름        LIFO : 마지막에 넣은 데이터를 가장 먼저 추출함   FILO : 처음에 넣은 데이터를 가장 마지막에 추출함   데이터를 스택에 넣는건 push() / 데이터를 스택에서 꺼내는건 pop()    💡큐(Queue)가 FIFO 라면, 스택(Stack)은 LIFO      🤩대표적인 장점   구조의 단순화/ 데이터의 저장,읽기 속도 빠름    😥대표적인 단점   데이터 최대 개수를 미리 정해야 하고, 미리 정한만큼 쓰지 못하면 저장공간의 낭비 발생       push와 pop을 이용한 예제코드   import java.util.Stack;  public class Test_stack {     public static void main(String[] args) {         Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();          stack.push(1); //1이 추가됨         stack.push(2); //2가 추가됨         stack.push(3); //3이 추가됨          stack.pop(); //3이 제거됨         stack.pop(); //2가 제거됨         System.out.println(stack);     } }       ArrayList를 이용해서 가변적으로 Stack(스택)에 데이터를 넣고 빼보자   import java.util.ArrayList;  public class Test_stack&lt;T&gt; {    private ArrayList&lt;T&gt; stack = new ArrayList&lt;T&gt;();     public void push(T i) {         stack.add(i); //add는 ArrayList의 객체    }     public T pop() {       if(stack.isEmpty()) {          return null;       }       //stack의 사이즈를 알 수 없기때문에 size 메소드로 값을 구한 뒤 -1을 해주면 끝자리 값이 삭제됨       return stack.remove(stack.size() - 1);    }     public boolean isEmpty() {       return stack.isEmpty();    }     public static void main(String[] args) {       Test_stack&lt;Integer&gt; ts = new Test_stack&lt;Integer&gt;();       ts.push(1); //1을 넣고       ts.push(2); //2를 넣고       System.out.println(ts.pop()); //2가 출력되고 값이 빠짐       ts.push(3); //3을 넣고       System.out.println(ts.pop()); //3이 출력되고 값이 빠짐       System.out.println(ts.pop()); //남은 값은 1로, 1이 출력됨 \t//2 3 1 순으로 출력된다.    } }  ","categories": ["Algorithm"],
        "tags": ["algorithm"],
        "url": "/algorithm/algorithm_stack/",
        "teaser": null
      }]
